%&"../ai"
\endofdump
\tikzexternalize[prefix=cache/]{project1}
\begin{document}
    \title{项目一：MSA}
    \maketitle
    % 1）对算法的描述以及算法实现结果分析；
    % 2）不同算法的搜索结果；
    % 3）不同算法的运行时间；
    % 4）复杂度分析。

    \tableofcontents
    \clearpage

    \section{题目}

    \subsection{Topic}

    Implement three algorithms to solve multiple sequence alignment (MSA) problems.

    \subsection{Requirements}

    \begin{enumerate}
        \item Implement dynamic programming (DP) algorithm to find the optimal solution.
        \item Implement A-star (A$^\ast$) algorithm to find the optimal solution.
        \item Implement genetic algorithm to find the optimal/suboptimal solution.
    \end{enumerate}

    \subsection{Rules}

    \begin{table}[H]
        \centering
        \caption{Cost Matrix}\label{tab:costmat}
        \begin{tabular}{cccc}
            \toprule
                & Match $\alpha(p,p)$ & Mismatch $\alpha(p,q)$ & Gap $\delta$ \\
            \midrule
            Cost & 0 & 3 & 2 \\
            \bottomrule
        \end{tabular}
    \end{table}

    The table above shows the pairwise cost matrix. For multiple sequence alignment, the cost should be calculated in a cycle pairwise manner. Note that GAP-GAP is a match and should be considered as 0 cost. For every query, find the best alignment(s) in the database with the lowest cost.

    \section{动态规划算法}

    \subsection{双序列比对}

    在算法与复杂性课程\cite{algcom}里，已经提到了双序列比对的动态规划算法，如图 \ref{fig:pairwisedp} 所示，双序列比对对于一个状态只需要考虑三个临近状态的转移，分别是对齐$\alpha$，间隔 $\delta_x$、$\delta_y$，转换行动如表 \ref{tab:pairwise} 所示。对于每一个状态，都需要考虑经过哪一条路径消耗最小，于是就有了如算法 \ref{alg:pairwise} 的动态规划状态转移方程。

    \begin{algorithm}[H]
        \caption{双序列比对动态规划 MSA}\label{alg:pairwise}
        \KwIn{$x_1x_2\cdots x_m, y_1y_2\cdots y_n,\alpha,\delta$}
        \KwOut{minimum cost}
        \BlankLine
        \lFor{$i\leftarrow 0$ to $m$}{$M[i,0]=i\delta$}
        \lFor{$j\leftarrow 0$ to $n$}{$M[0,j]=j\delta$}
        \For{$i\leftarrow 1$ to $m$}{
            \For{$j\leftarrow 1$ to $n$}{
                $M[i,j]=\min(\alpha[x_i,y_j] + M[i-1,j-1], \delta + M[i-1,j], \delta + M[i,j-1])$\;
            }
        }
        \Return{$M[m,n]$}\;
    \end{algorithm}

    \begin{minipage}{0.48\textwidth}
        \begin{table}[H]
            \centering
            \caption{双序列行动坐标变换表}\label{tab:pairwise}
            \begin{tabular}{crr}
                \toprule
                    & $i$ & $j$ \\
                \midrule
                $\alpha$ & $+1$ & $+1$ \\
                $\delta_x$ & $0$ & $+1$ \\
                $\delta_y$ & $+1$ & $0$ \\
                \bottomrule
            \end{tabular}
        \end{table}
    \end{minipage}\hfil
    \begin{minipage}{0.48\textwidth}
        \begin{figure}[H]
            \centering
            \input{fig/pairwise_dp.tex}
            \caption{动态规划双序列比对}\label{fig:pairwisedp}
        \end{figure}
    \end{minipage}
    \medskip
    
    \subsection{多序列比对}

    对于三序列比对，情况就复杂地多，需要同时考虑七条路径。

    \begin{minipage}{0.48\textwidth}
        \begin{table}[H]
            \centering
            \caption{三序列行动坐标变换表}\label{tab:multiple}
            \begin{tabular}{crrr}
                \toprule
                    & $k$ & $j$ & $i$ \\
                \midrule
                $\alpha_x\delta_y\delta_z$  & 0 & 0 & 1\\
                $\delta_x\alpha_y\delta_z$ & 0 & 1 & 0 \\
                $\delta_x\alpha_y\alpha_z$ & 0 & 1 & 1 \\
                $\delta_x\delta_y\alpha_z$ & 1 & 0 & 0 \\
                $\alpha_x\delta_y\alpha_z$ & 1 & 0 & 1 \\
                $\alpha_x\alpha_y\delta_z$ & 1 & 1 & 0 \\
                $\alpha_x\alpha_y\alpha_z$ & 1 & 1 & 1 \\
                \bottomrule
            \end{tabular}
        \end{table}
    \end{minipage}\hfil
    \begin{minipage}{0.48\textwidth}
        \begin{figure}[H]
            \centering
            \input{fig/multiple_dp.tex}
            \caption{动态规划三序列比对}\label{fig:multipledp}
        \end{figure}
    \end{minipage}
    \medskip

    可以统一化为多序列比对问题。对于 $L$ 条序列比对，首先需要递归地初始化低维度边缘（如图 \ref{fig:downdim} 所示，注意附加高维度的间隙），之后余下空间其行动转换方法可以被表示为二进制从 $(\underbrace{0\cdots01}_{L\text{ digits}})_2$ 到 $(\underbrace{1\cdots11}_{L\text{ digits}})_2$ 内所有的数（最低位为第一维度），计算损耗使用上三角成对比较，规则统一为
    \begin{equation*}
        \texttt{compare}=
        \begin{cases}
            0,& (-,-) \| (p,p) \\
            2,& (p,-) \| (-,q) \\
            3,& (p,q)
        \end{cases}
    \end{equation*}
    并在确定每一次行动后记录路径，最后回溯路径到原点。

    \begin{figure}[H]
        \centering
        \input{fig/dp_downdim.tex}
        \caption{降维递归}\label{fig:downdim}
    \end{figure}

    % 29s
    % > 24h
    % 8 核多线程进行中

    几乎类似于双序列比对，下面是 \verb"numpy" 实现版本，虽然其速度没有使用 Python 内置的 \verb"list" 版本（\href{./msa\_mdp.py}{\ttfamily msa\_mdp.py}）的快，但是代码可读性已经与伪代码相当。

    \codeseg[language=python]{msa\_ndp.py}{29}{73}

    \subsection{运行时间}

    如果字符串平均长度为 $l$，该算法 $L$ 维字符串的复杂度为：
    \begin{equation*}
        O_S = \prod_{i=1}^L \texttt{len}(S[i]) = O(l^L)
    \end{equation*}

    对于该问题，有 $m$ 个待比对序列，$n$ 个数据库项目，总时间复杂度为：
    \begin{equation*}
        mC_{n}^{L-1}O_S \approx mC_{n}^{L-1}l^L
    \end{equation*}

    实际运行时间如表 \ref{tab:dp}，在服务器上运行时间如下。

    \begin{table}[h]
        \centering
        \caption{动态规划运行时间}\label{tab:dp}
        \begin{tabular}{cb{3cm}b{3cm}b{3cm}b{3cm}}
            \toprule
             &\multicolumn{2}{c}{\bfseries 双序列}  &\multicolumn{2}{c}{\bfseries 三序列} \\
             \cmidrule(r){2-3}\cmidrule(r){4-5} 
             & \bfseries 朴素实现 \href{./msa\_dp.py}{\ttfamily msa\_dp.py} &\bfseries \verb"list"实现 \href{./msa\_mdp.py}{\ttfamily msa\_mdp.py} &\bfseries \verb"list" 实现 \href{./msa\_mdp.py}{\ttfamily msa\_mdp.py} &\bfseries \verb"numpy" 实现 \href{./msa\_ndp.py}{\ttfamily msa\_ndp.py} \\
            \midrule
            运行时间 & 29s & 1min & 48h & $\sim$72h \\
            \bottomrule
        \end{tabular}
    \end{table}

    \section{A* 算法}

    \subsection{算法描述}

    A* 算法会从后继结点中首先扩展评估函数 $f(n)=g(n)+h(n)$ 最小的结点，如果 $h(n)$ 的选择满足可满足启发式和一致性的性质，就可以找到按照贪婪算法的思想找到最优解。

    这里将会非常乐观地估计剩下的字符串剩余部分都可以完美匹配，只会剩余间隔损耗。对于状态为 $n$ 的启发函数就可以被定义为轮换剩余长度差的和之下界
    \begin{equation*}
        \delta\sum_{cyc} \left|(l_1-\texttt{pos}[i])-(l_2-\texttt{pos}[j])\right| \geq \delta \left(L\max a_i - \sum_i a_i\right) = h(n)
    \end{equation*}
    其中
    \begin{equation*}
        a_i = l_i - \texttt{pos}[i]
    \end{equation*}

    % 这种由乐观得到的启发函数使得对角线上的每一步都被估计为 0，易证为满足\textbf{可满足启发式}。

    不等式容易从下面图 \ref{fig:gap} 的可视分析中论证，这样选择的 $h(n)$ 满足\textbf{可满足启发式}。

    \begin{figure}[H]
        \centering
        \input{fig/gap_calc.tex}
        \caption{每一个间隔都至少贡献了一次}\label{fig:gap}
    \end{figure}

    之后来证明\textbf{一致性}。对于 A* 算法而言，其下一步的定义如图 \ref{fig:pairwiseastar} 和 \ref{fig:multipleastar} 所示。此处每一步的损耗都会大于等于0，而这种最好情况只会在全部序列都减少了 1 长度才会产生（超体对角线），这种情况下$h(n)=h(n^\prime)$；由于坐标至少在某一维度上增加了 1，一旦产生了间隙，就会有至少 2 的损耗，但是启发函数只会对应地减少 1，所以这个函数将满足一致性：
    \begin{equation*}
        h(n)\leq c(n,a,n^\prime) + h(n^\prime)
    \end{equation*}

    \begin{figure}[H]
        \centering
        \input{fig/gap_tri.tex}
        \caption{前进一步的不等式贡献}\label{fig:gaptri}
    \end{figure}

    \begin{figure}[h]
        \centering
        \begin{minipage}{0.48\textwidth}
            \centering
            \input{fig/pairwise_astar.tex}
            \caption{A* 双序列比对}\label{fig:pairwiseastar}
        \end{minipage}
        \begin{minipage}{0.48\textwidth}
            \centering
            \input{fig/multiple_astar.tex}
            \caption{A* 三序列比对}\label{fig:multipleastar}
        \end{minipage}
    \end{figure}

    伪代码描述如算法 \ref{alg:astar} 所示\cite{astarwiki}，其中可选行动随着坐标的不同可能会被限制，这样就会首先扩展评估函数最小的结点。

    \begin{algorithm}[h]
        \caption{A* 多序列比对}\label{alg:astar}
        \KwIn{$L$个字符串列表$S$,$\alpha$,$\delta$}
        \KwOut{minimum cost}
        \BlankLine
        $dist[\cdot]\leftarrow\infty$\;
        $move[\cdot]\leftarrow 0$\;
        $dist[start]\leftarrow 0$\;
        $move[start]\leftarrow 0$\;
        $openSet\leftarrow\textsc{Min-Heap}()$\;
        $openSet[start]=h(start)$\;
        $closeSet\leftarrow \{\}$\;
        \Repeat{$openSet$ is empty}{
            $current\leftarrow openSet$.pop()\;
            \If{$current$=$finish$}{
                \Return{$dist[current]$}\;
            }

            $closeSet$.add($current$)\;
            \ForEach{avaliable move of $current$}{
                $n\leftarrow$\texttt{pos}$+$\emph{avaliable move}\;
                $g(n)=cost+\texttt{comparelist}(\textit{avaliable move})$\;
                \If{$g(n)<dist[n]$}{
                    $move[n]\leftarrow$\emph{avaliable move}\;
                    $dist[n]\leftarrow g(n)$\;
                    \If{$n$ not in $closeSet$}{
                        $openSet[n]\leftarrow g(n)+h(n)$\;
                    }
                }
            }
        }
        \Return{$\infty$}\;
    \end{algorithm}


    \subsection{运行时间}

    该算法的时间复杂度，对于 $L$ 个字符串（平均长度为 $l$），最多进行 $\sum_i l_i=Ll$ 步（如果平均长度为 $l$ 的话），每一步的分支因子为 $2^{L}-1$，单个实例需要花费时间
    \begin{equation*}
        (2^L-1)\sum_i l_i = L(2^L-1)l = O(l)
    \end{equation*}
    因为这是一个树状结构的图，所以一定能够找到路径。当然如果有多个最小节点的情况，这个复杂度会变差，这个问题里不匹配都会有 3 的损耗，而不是 ASCII 距离，就会导致这种情况出现的可能性飙升，影响 A* 应当有的快速度。但最多不会超过$O((2^L-1)^{Ll})$（实际上应当多项式时间内即可，这个是 A* 的最差复杂度）。

    \begin{table}[H]
        \centering
        \caption{A* 运行时间}\label{tab:astar}
        \begin{tabular}{ccc}
            \toprule
             & 双序列比对 & 三序列比对 \\
            \midrule
            运行时间 & 2min & $\sim$ \\
            \bottomrule
        \end{tabular}
    \end{table}

    \section{遗传算法}

    \subsection{算法描述}
    
    参照简单遗传算法\cite{simplega}

    \bibliography{ref}

\end{document}